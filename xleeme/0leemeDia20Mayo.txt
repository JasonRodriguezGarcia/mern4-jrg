tipos join
https://ingenieriadesoftware.es/tipos-sql-join-guia-referencia/

Entramos en 5050
query con
    SELECT *
    FROM scott.dept as d
    inner JOIN scott.emp as e ON e.deptno = d.deptno

https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/repaso-biblioteca.md


CREATE SCHEMA IF NOT EXISTS biblioteca;


CREATE TABLE biblioteca.socios (
    id_socio SERIAL PRIMARY KEY,
    nombre TEXT NOT NULL,
    correo TEXT UNIQUE NOT NULL
);

CREATE TABLE biblioteca.libros (
    id_libro SERIAL PRIMARY KEY,
    titulo TEXT NOT NULL,
    autor TEXT NOT NULL
);

CREATE TABLE biblioteca.prestamos (
    id_prestamo SERIAL PRIMARY KEY,
    id_socio INT REFERENCES biblioteca.socios(id_socio),
    id_libro INT REFERENCES biblioteca.libros(id_libro),
    fecha_prestamo DATE NOT NULL,
    fecha_devolucion DATE
);

-- Socios
INSERT INTO biblioteca.socios (nombre, correo) VALUES
('Ana López', 'ana@correo.com'),         -- Ha hecho préstamos
('Carlos Pérez', 'carlos@correo.com'),   -- Ha hecho préstamos
('Lucía Gómez', 'lucia@correo.com'),     -- Ha hecho préstamos
('Mario Díaz', 'mario@correo.com');      -- NO ha hecho ningún préstamo

-- Libros
INSERT INTO biblioteca.libros (titulo, autor) VALUES
('Cien años de soledad', 'Gabriel García Márquez'),  -- Prestado
('El túnel', 'Ernesto Sabato'),                      -- Prestado
('Don Quijote de la Mancha', 'Miguel de Cervantes'), -- Prestado
('Rayuela', 'Julio Cortázar');                       -- NO ha sido prestado

-- Préstamos
INSERT INTO biblioteca.prestamos (id_socio, id_libro, fecha_prestamo, fecha_devolucion) VALUES
(1, 1, '2024-05-01', '2024-05-10'), -- Ana -> Cien años
(1, 2, '2024-05-11', NULL),         -- Ana -> El túnel
(2, 1, '2024-05-03', '2024-05-12'), -- Carlos -> Cien años
(3, 3, '2024-05-05', NULL);         -- Lucía -> Don Quijote

PARTE 1
Llevar a cabo lo siguiente:

Queremos saber si hay socios que aún no han realizado préstamos. Mostrar solo el socio que no ha realizado un
 préstamo.
SELECT s.nombre FROM biblioteca.prestamos p
RIGHT JOIN biblioteca.socios s ON s.id_socio = p.id_socio
WHERE p.id_prestamo IS NULL

Muestra una lista de todos los préstamos, incluyendo el nombre del socio, el título del libro y la fecha del
 préstamo.
SELECT s.nombre, l.titulo, p.fecha_prestamo FROM biblioteca.prestamos p
LEFT JOIN biblioteca.socios s ON s.id_socio = p.id_socio
LEFT JOIN biblioteca.libros l ON l.id_libro = p.id_libro

Queremos saber qué libros han sido prestados y cuáles no.
SELECT l.titulo, l.autor FROM biblioteca.libros l
LEFT JOIN biblioteca.prestamos p ON l.id_libro = p.id_libro
WHERE p.fecha_prestamo IS NOT NULL

Queremos saber qué libros estan actualmente prestados y a qué socio están prestados. Crear una vista llamada
 "vw_libros_prestados" para esta consulta, dandole permisos de lectura a la aplicacion de Python para sacar los informes.
SELECT * FROM biblioteca.libros l
INNER JOIN biblioteca.prestamos p ON l.id_libro = p.id_libro
WHERE p.fecha_devolucion IS NULL

Añadir unos nuevos libros a la tabla libros. Escribir el código SQL. 'Ana Lopez' ha prestado dos libros más.
INSERT INTO biblioteca.libros(
	titulo, autor)
	VALUES 
	('La cosa', 'Eddy Murphy'),
	('Como hacerse millonario', 'Ronaldo Trump');

INSERT INTO biblioteca.prestamos (id_socio, id_libro, fecha_prestamo) 
VALUES (1, 4, NOW()),
(1, 4, NOW());

Escribir el código SQL para insertar su prestámo. Hoy, "Lucía Gómez" ha devuelto su libro "Don Quijote de la Mancha".
UPDATE biblioteca.prestamos
SET fecha_devolucion=Now()
WHERE id_socio = 3 AND id_libro = 3

Queremos saber cuántos libros prestados tiene cada socio actualmente. Si el valor es mayor a 3, mostrar los
 resultados. Si es menos de 3, no hay ningun problema, asi que no les mostramos. De nuevo, Crear una vista llamada
  "vw_libros_prestados_importantes" para esta consulta, dandole permisos de lectura a la aplicacion de Python para
   sacar los informes.
PENDING¿?

Crear esta función para sacar el nombre del autor, y pasando un identidad como parametro de entrada (IN): 
biblioteca.get_autor_by_id(_id_libro integer). Usarlo como se ve en la imagen:
defininicion
    retorno character varing
    tipo datos +
        integer IN _idlibro
SELECT biblioteca.get_autor2(5);
SELECT *, biblioteca.get_autor2(id_libro) AS AUTOR
FROM biblioteca.prestamos


¿Podrias incluir tambien el titulo del libro? PODEMOS CREAR OTRO PERO SOLO DEVUELVE EL titulo
O BIEN CREAR OTRO
definicion
    retorno record
    plpsql

    tipo datos +
        integer IN _idlibro
        TEXT OUT _autor
        text out _titulo
    CODIGO
        begin

        SELECT autor, titulo
        INTO _autor, _titulo
        FROM biblioteca.libros
        WHERE id_libro = _idlibro;

        END;

 ¿Podrias crear una vista con este consulta?


******************
https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/06-db.functions.md
FUNCIONES

select funciones

CREATE FUNCTION scott.obtener_salario(p_empno INTEGER)
RETURNS NUMERIC AS $$
DECLARE
    salario NUMERIC;
BEGIN
    SELECT sal INTO salario FROM scott.emp WHERE empno = p_empno;
    RETURN salario;
END;
$$ LANGUAGE plpgsql;

Crea funcion en Funciones dentro del esquema Scott
uso en query cualquiera
select scott.obtener_salario(7839);
devuelve 5000.00

select *, scott.obtener_salario(7839) FROM scott.emp

select *, scott.obtener_salario(empno) FROM scott.emp

SELECT * FROM scott.emp
WHERE scott.obtener_salario(empno) > 1000

crear consulta
get_todos_empleados
Definicion
    tipo retorno
        scott.emp --devolvera una tabla
    Lenguage
        sql
    CODIGO
        SELECT * FROM scott.emp;
    options
        activar returs a set
    SALVAR

usar en cualquier lado
SELECT * FROM scott.get_todos_empleados();

crear otra
get_empleado
    tipo retorno
        record
    añadir parametro
        INTEGER
        IN
        ARGUMENTO _empno
CODE
    SELECT *
    FROM scott.emp
    WHERE empno = _empno;
options
    DEJAMOS IGUAL


Crear FUNCIONA
-- GET EMPLEADO COUNT
    CODIGO  
        SELECT COUNT(*) FROM scott.emp;

SELECT scott.get_empleados_cuenta();

-- MOSTRAR DEPT NOMBRE PARA UN EMPLEADO
General
    get_empleado_nombre
Definicion
    tipo del retorno character varing
    Argumentos
        tipo datos INTEGER
        modo IN
        argument name _empno
    CODIGO
        SELECT d.dname FROM scott.emp e
        INNER JOIN scott.dept d on e.deptno = d.deptno
        WHERE e.empno = _empno;
SALVAR
USO funcion
    SELECT scott.get_empleado_nombre(7499)


los mismo pero con plpsql
SELECT ename, sal  -- valores out
FROM scott.emp
WHERE empno = 7839

crear funcion test4
tipo retorno record
lenguaje plpsql
Argumentos
    integer
    in
    _empno

    character varing
    output
    emp_name
    numeric out emp_salario


BEGIN

SELECT ename, sal 
INTO emp_name, emp_salario
FROM scott.emp
WHERE empno = _empno;

END;


SELECT * FROM scott.test4(7839)


function test5
tipo retorno numeric
lenguaje plpgsql
Argumentos
    integer in _empno
Codigo
DECLARE
	salario NUMERIC;
	resultado NUMERIC;

BEGIN
	SELECT sal
	INTO salario
	FROM scott.emp
	WHERE empno = _empno;
		resultado := salario + 100;

		--raise notice ' salario: %', resultado; -- IMPRIMIR EN PANTALL
	RETURN resultado;
END;

SELECT * FROM scott.test5(7839)

https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/repaso-biblioteca.md
parte 2 

definicion
    tipo retorno integer
    Argumentos
        tipo datos integer IN _idsocio
    Codigo
SELECT count(*) FROM biblioteca.prestamos
WHERE id_socio = _idsocio AND fecha_devolucion IS NULL

OJO GUARDE LA FUNCION POR ERROR EN SQUEMA SCOTT DEBERIA SER BIBLIOTECA
SELECT id_socio, nombre, scott.libros_prestados(id_socio) FROM biblioteca.socios



inse upd dele procedimientos


******************
https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/07-db.indexes.md

INDICES
en postgress los indices con b-tree (autobalanceado) y no clustered, en sqlserver sí
ventaja rendimiento consultas
desventaja bajo rend en inserts

SELECT * FROM clientes  -- seleccionar y boton E explain en los iconos de arriba de la consulta
muesta consulta sequential scanning

SELECT * FROM clientes WHERE id = 600 -- usa indice primario al pulsar Explain muestra que usa btree (balancing tree)

SELECT * FROM clientes WHERE id > 600 and id <800 -- usa sequential
SELECT * FROM clientes WHERE id > 600 and id <610 -- usa btree
SELECT * FROM clientes WHERE email = 'cliente999@correo.com' -- usa sequential
SELECT * FROM clientes WHERE saldo > 8000 -- usa sequential

con esto revisamos qué tipo de búsquedas se hacen para cambiar para ver que va mejor

en la tabla
indices
crear indice
    generalnombre idx_email
columnas
    desactivar IS EXPRESSION
    email ADD
SALVAR

SELECT * FROM clientes WHERE email = 'cliente999@correo.com'  -- AHORA USA btree
SELECT * FROM clientes WHERE email IN ('cliente999@correo.com', 'cliente3@correo.com', 'cliente888@correo.com') -- tarda menos

86ms

121ms
SELECT * FROM clientes
WHERE UPPER(ciudad) ='MADRID'

columnas
    is EXPRESSION
    expresion UPPER(CIUDAD)
99ms

en indice definicion (avanzado)
FACTOR DE LLENADO 
    90 (porcentaje)



Actividad
-- Se estan quejando los usuarios sobre el rendimiento de la aplicacion web al sacar un informe. Mejorar el 
rendimiento de las siguientes consultas:

SELECT *
FROM orders
WHERE product_name = 'Product_25';
68ms

SELECT *
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';

SELECT order_date
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2025-01-31'; -- va algo más rápido respecto a la expresion anterior

72ms
63ms

SELECT * 
FROM orders
ORDER BY customer_name DESC
400ms
152ms

SELECT * FROM orders
WHERE UPPER(product_name) IN ('PRODUCT_86', 'PRODUCT_13', 'PRODUCT_49');

145ms
90ms

SELECT email, ciudad FROM clientes
WHERE ciudad = 'Madrid' AND saldo > 8000;
122ms
85ms
81ms

*************
EJERCICIO RAPIDO
*************
CREATE SCHEMA IF NOT EXISTS borraremp AUTHORIZATION postgres;

CREATE TABLE borraremp.departamentos(
	dept_id SERIAL PRIMARY KEY,
	departamento TEXT
);

CREATE TABLE borraremp.empleados (
	emp_id SERIAL PRIMARY KEY,
	nombre TEXT,
	dept_id INT REFERENCES borraremp.departamentos(dept_id)
);

INSERT INTO borraremp.departamentos (departamento)
VALUES
('VENTAS'),
('INFORMATICA'),
('CONTABILIDAD'),
('MARKETING');

INSERT INTO borraremp.empleados (nombre, dept_id)
VALUES
('PEPE', 1),
('JUAN', 1),
('MARIA', 2),
('JOSE', 3),
('ANTONIA', 4);

UPDATE borraremp.empleados SET nombre = 'PEPA', dept_id = '4' WHERE emp_id = 1;
UPDATE borraremp.departamentos SET departamento = 'COMERCIAL' WHERE departamento = 'VENTAS';
UPDATE borraremp.empleados SET dept_id = null WHERE emp_id = 2;

SELECT e.emp_id, e.nombre, e.dept_id, d.departamento FROM borraremp.empleados e
INNER JOIN borraremp.departamentos d ON d.dept_id = e.dept_id
ORDER BY e.nombre;

DELETE FROM borraremp.empleados WHERE emp_id = 2;

-- Eliminar el esquema y todo su contenido
DROP SCHEMA IF EXISTS borraremp CASCADE;
*************
*************
PARTE 3 Indices
Nos dice que el correo electronico de los socios tiene que ser único, ya que muchos socios estan 
registrando con el correo de sus amigos y familiares. Aplicar una restriccion único.

¿Lo ves?

SELECT indexname, indexdef
FROM pg_indexes
En la aplicacion de Python, se suele llevar a cabo los siguientes consultas. ¿Cómo mejorarías estas consultas con indices?

SELECT * FROM biblioteca.libros WHERE titulo ILIKE '%cien%';
80ms
SELECT * FROM biblioteca.libros WHERE autor = 'Gabriel García Márquez';

************

PROCEDIMIENTOS ALMACENADOS
es lenguaje plpgsql
nomenclatura "usp_xxxxx"

DO $$

DECLARE
	id integer := 0;

BEGIN

	RAISE NOTICE 'hola %', id;

END;

$$ language plpgsql


******************
esqueleto
******************
DO $$

BEGIN

END;

$$ language plpgsql

***************
en postgres procedimiento para insert, update, delete EN OTROS NO SABEMOS

DO $$ --sobra en procedimiento esto es para usar en query de pruebas

DECLARE
	id integer := 30;
	nombre varchar(100);

BEGIN

	RAISE NOTICE 'hola %', id; -- CONSOLE.LOG
	-- RAISE EXCEPTION 'ERROR !!! %', nombre; -- PARA MOSTRAR ERRORES 'EXECPTION'
	SELECT dname 
	INTO nombre 
	FROM scott.dept
	WHERE deptno = id;

	RAISE NOTICE 'result: %', nombre;
END;

$$ language plpgsql --sobraría en procedimientos

***************

se llaman con CALL procedimiento
CALL scott.print_deptname(10)

***************
EJECUTANTO EN CONSULTA SUELTA
--CALL scott.print_deptname(10)

DO $$

DECLARE
	id integer := 10; -- 20
	nombre varchar(100);

BEGIN

	RAISE NOTICE 'hola %', id; -- CONSOLE.LOG
	-- RAISE EXCEPTION 'ERROR !!! %', nombre; -- PARA MOSTRAR ERRORES 'EXECPTION'
	SELECT dname 
	INTO nombre 
	FROM scott.dept
	WHERE deptno = id;

	IF nombre = 'ACCOUNTING' THEN
		RAISE EXCEPTION 'No se pueden ver los datos de Contabilidad';
	ELSE
		RAISE EXCEPTION 'Hola %', nombre;
	END IF;
	RAISE NOTICE 'departamento: %', nombre;
END;

$$ language plpgsql

*********
probando en query SUELTA
DO $$

DECLARE

	_deptno integer := 100;
	_dname varchar(15) :='TESTING';
	_loc varchar(100) := 'Bilbao';

BEGIN

	IF _loc = 'San Sebastian' THEN
		RAISE EXCEPTION 'No se puede montar en SS';
	ELSE
		INSERT INTO scott.dept (deptno, dname, loc)
		VALUES (_deptno, _dname, _loc);
		RAISE NOTICE 'Hemos insertado % correctamente en %', _dname, _deptno;
	END IF;
END;

$$ language plpgsql

LUEGO EN PROCEDIMIENTO
definicion
    lenguaje plpgsql    --- OJO !!!
    Argumentos
        integer IN _deptno
        character varing IN _dname
        character varing IN _loc
codigo
BEGIN

	IF _loc = 'San Sebastian' THEN
		RAISE EXCEPTION 'No se puede montar en SS';
	ELSE
		INSERT INTO scott.dept (deptno, dname, loc)
		VALUES (_deptno, _dname, _loc);
		RAISE NOTICE 'Hemos insertado % correctamente en %', _dname, _deptno;
	END IF;
END;
***************
https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/08-db.storedprocedures.md
EJEMPLO 3
crear procedimiento

plpgsql
integer in _deptno

BEGIN

	IF EXISTS (SELECT 1 FROM scott.dept WHERE deptno = _deptno) THEN
		DELETE FROM scott.dept WHERE deptno = _deptno;
	ELSE
		RAISE EXCEPTION 'deptno % no existe', _deptno;
	END IF;
END;

CALL scott.delete_dept(40)

***************
Actividad 1: UPSERT 
Actualizar el procedimiento de ejemplo 4 en la tabla scott.dept. Queremos que sea un UPSERT, es decir, si existe
 lo actualizamos y si no existe lo insertamos.

NOTAS: El término upsert proviene de la combinación de dos palabras en inglés: update (actualizar) y insert (insertar).
 Un upsert es una operación en bases de datos que intenta insertar un nuevo registro, pero si ese registro ya existe 
 (normalmente determinado por una clave primaria o única), en lugar de insertar un duplicado, actualiza el registro 
 existente con los nuevos datos.

Es decir, upsert = insertar si no existe, actualizar si existe.

Ahora, cambiar el contenido del procedimiento para que use la sentencia ON CONFLICT de postgres:

codigo
DO $$

DECLARE

	_deptno integer := 50;
	_dname varchar(15):= 'Ventas';
	_loc varchar(15):= 'Beasain';
	

BEGIN

	IF EXISTS (SELECT 1 FROM scott.dept WHERE deptno = _deptno) THEN
		UPDATE scott.dept 
		SET deptno = _deptno, dname = _dname, loc = _loc
		WHERE deptno = _deptno;
		RAISE NOTICE 'ACTUALIZACION CORRECTA';
	ELSE
		INSERT INTO scott.dept (deptno, dname, loc)
		VALUES (_deptno, _dname, _loc);
		RAISE NOTICE 'INSERCION CORRECTA';
	END IF;
		
END;

************
https://github.com/chekulhan/Desarrollo-Web/blob/main/UF1845-Acceso-a-Datos/postgres/repaso-biblioteca.md
PARTE 4 Stored Procedures
BBDD BIBLIOTECA
Validación de correo electrónico Crear un procedimiento almacenado que inserte un nuevo socio en la tabla socios. Agregar lógica de negocio para excluir cualquier correo electrónico que no contenga el dominio @nazaret.eus. Si el correo electrónico no es válido, el procedimiento debe lanzar una excepción (o mensaje) y no insertar el nuevo socio.
PISTA:
IF _correo NOT ILIKE '%@nazaret.eus' THEN
Definicion
    lenguaje    plpgsql
    INTEGER IN _id_socio
    character varing in _nombre
    character varing in _correo

codigo
BEGIN

	IF _correo NOT ILIKE '%@nazaret.eus' THEN
		RAISE NOTICE 'CORREO NO VALIDO';
	ELSE -- DESGLOSAR EL INSERT Y EL UPDATE Y PROBAR EN PYTHON
		INSERT INTO biblioteca.socios (id_socio, nombre, correo)
		VALUES (_id_socio, _nombre, _correo)
		ON CONFLICT (id_socio)
		DO UPDATE SET
			nombre = EXCLUDED.nombre,
			correo = EXCLUDED.correo;
	END IF;		

		
END;

testing
CALL biblioteca.insert_update_socio_checking_email(21, 'Botones Sacarino', 'botones@gmail.com')




